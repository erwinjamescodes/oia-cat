<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fidget Spinner</title>
    <style>
      body {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background-color: #f0f0f0;
      }
      .spinner-container {
        position: relative;
        width: 300px;
        height: 300px;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      .spinner {
        width: 300px;
        height: 300px;
        position: relative;
        cursor: pointer;
        user-select: none;
        transform-style: preserve-3d;
      }
      /* Spinner Image */
      .spinner-image {
        position: absolute;
        width: 300px;
        height: 300px;
        top: 0;
        left: 0;
        background-image: url("https://ffffidget.com/img/spinner.png");
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
      }
    </style>
  </head>
  <body>
    <div class="spinner-container">
      <div class="spinner" id="spinner">
        <div class="spinner-image"></div>
      </div>
    </div>

    <script>
      const spinner = document.getElementById("spinner");
      let isDragging = false;
      let previousX = 0;
      let previousY = 0;
      let rotation = 0;
      let velocity = 0;
      const friction = 0.98;
      let lastTime = null;

      // Start dragging
      spinner.addEventListener("mousedown", (e) => {
        isDragging = true;
        previousX = e.clientX;
        previousY = e.clientY;
        velocity = 0; // Reset velocity on new drag
        e.preventDefault(); // Prevent text selection
      });

      // Touch support
      spinner.addEventListener("touchstart", (e) => {
        isDragging = true;
        previousX = e.touches[0].clientX;
        previousY = e.touches[0].clientY;
        velocity = 0; // Reset velocity on new drag
        e.preventDefault();
      });

      // Stop dragging
      document.addEventListener("mouseup", () => {
        isDragging = false;
      });

      document.addEventListener("touchend", () => {
        isDragging = false;
      });

      // Calculate rotation based on drag
      document.addEventListener("mousemove", (e) => {
        if (isDragging) {
          const rect = spinner.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;

          // Calculate the angle between the current and previous positions relative to the center
          const currentAngle = Math.atan2(
            e.clientY - centerY,
            e.clientX - centerX
          );
          const previousAngle = Math.atan2(
            previousY - centerY,
            previousX - centerX
          );

          // Calculate the angle difference and convert to degrees
          let deltaAngle = (currentAngle - previousAngle) * (180 / Math.PI);

          // Smoother rotation with adaptive sensitivity
          velocity = deltaAngle * 1.5;
          rotation += deltaAngle;
          spinner.style.transform = `rotate(${rotation}deg)`;

          previousX = e.clientX;
          previousY = e.clientY;
        }
      });

      // Touch move support
      document.addEventListener("touchmove", (e) => {
        if (isDragging) {
          const rect = spinner.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;

          const currentAngle = Math.atan2(
            e.touches[0].clientY - centerY,
            e.touches[0].clientX - centerX
          );
          const previousAngle = Math.atan2(
            previousY - centerY,
            previousX - centerX
          );

          let deltaAngle = (currentAngle - previousAngle) * (180 / Math.PI);

          // Smoother rotation with adaptive sensitivity
          velocity = deltaAngle * 1.5;
          rotation += deltaAngle;
          spinner.style.transform = `rotate(${rotation}deg)`;

          previousX = e.touches[0].clientX;
          previousY = e.touches[0].clientY;
        }
        e.preventDefault(); // Prevent scrolling while dragging
      });

      // Simulate inertia and friction with time-based animation
      function animate(timestamp) {
        if (lastTime === null) {
          lastTime = timestamp;
        }
        const deltaTime = timestamp - lastTime;
        lastTime = timestamp;

        if (!isDragging && Math.abs(velocity) > 0.1) {
          // Apply time-based friction for more consistent spinning across devices
          const timeScale = deltaTime / 16.67; // Normalize based on 60fps
          velocity *= Math.pow(friction, timeScale);
          rotation += velocity * timeScale;
          spinner.style.transform = `rotate(${rotation}deg)`;
        }
        requestAnimationFrame(animate);
      }

      requestAnimationFrame(animate);

      // Add ability to stop spinner with a tap/click when it's spinning
      spinner.addEventListener("click", () => {
        if (!isDragging && Math.abs(velocity) > 1) {
          velocity = 0;
        }
      });

      // Add keyboard controls
      document.addEventListener("keydown", (e) => {
        if (e.key === "ArrowLeft") {
          velocity -= 2;
        } else if (e.key === "ArrowRight") {
          velocity += 2;
        } else if (e.key === " ") {
          // Spacebar to stop
          velocity = 0;
        }
      });
    </script>
  </body>
</html>
